import numpy as np
import matplotlib.pyplot as plt
while i<1:
    # Parámetros
    lpm = int(input("Ingrese sus latidos por minuto"))  # latidos por minuto
    # Volúmenes
    vol_d = int(input("Ingrese su volumen sanguineo diastolico: "))  # volumen diastólico
    vol_s = int(input("Ingrese su volumen sanguineo sistolico: "))   # volumen sistólico
    # Presiones
    pres_d = int(input("Ingrese su presion diastolica"))  # presión diastólica
    pres_s = int(input("Ingrese su presion sistolica"))   # presión sistólica
    estado=input("Ingrese el estado en el que se encuentra el paciente:1(En reposo),2(Trotando),3(Corriendo),4(Fibrilacion),5(Arritmia(bradicardia),6(muerte)):")
    if estado=="1":
        lpm=lpm
        vol_d=vol_d
        vol_s=vol_s
        pres_d=pres_d
        pres_s=pres_s
        T = 60 / lpm  # periodo total en segundos
    elif estado=="2":
        lpm=lpm*1.8
        vol_d=vol_d+30
        vol_s=vol_s+30
        pres_d=pres_d+30
        pres_s=pres_s
        T = 60 / lpm  # periodo total en segundos
    elif estado=="3":
        lpm=lpm*2.2
        vol_d=vol_d+30
        vol_s=vol_s+30
        pres_d=pres_d+40
        pres_s=pres_s
        T = 60 / lpm  # periodo total en segundos
    elif estado=="4":
        lpm=lpm+np.random.randint(5,15)
        vol_d=vol_d
        vol_s=vol_s
        pres_d=pres_d
        pres_s=pres_s
        T = 60 / lpm  # periodo total en segundos
    elif estado=="5":
        lpm=lpm+np.random.randint(-5,-15)
        vol_d=vol_d
        vol_s=vol_s
        pres_d=pres_d
        pres_s=pres_s
        T = 60 / lpm  # periodo total en segundos
    elif estado=="6":
        T = 60 / lpm  # periodo total en segundos
        lpm=lpm*0
        vol_d=vol_d*0
        vol_s=vol_s*0
        pres_d=pres_d*0
        pres_s=pres_s*0
    else:
        print("No eligio ningun estado")

    vol_medio = vol_d - vol_s  # volumen medio (amplitud de cambio en el volumen)
    num_ciclos = 5  # número de ciclos a simular
    tiempo_total = np.linspace(0, num_ciclos * T, num_ciclos * 1000)  # tiempo para varios ciclos
    # Parámetros del ciclo cardíaco
    F = lpm / 60  # frecuencia en Hz
    tiempo = np.linspace(0, 5 * T, 5000)  # tiempo para cinco ciclos


    pres_amplitud = (pres_d - pres_s) / 2
    pres_media = (pres_d + pres_s) / 2
    # Definición de las funciones para cada fase de la presión
    def p1(x):
        return pres_media + pres_amplitud * np.sin(3 / 2 * np.pi * (lpm / (60 * 3 / 8)) * x - 1 / 2 * np.pi)

    def p2(x):
        return pres_media + (pres_amplitud / 2) * np.sin(3 / 2 * np.pi * (lpm / (60 * (3 / 8))) * x - 1 / 2 * np.pi)

    def p3(x):
        return pres_media + pres_amplitud * np.sin(-np.pi * (lpm / (60 * (5 / 8))) * x - np.pi)

    # Función para calcular la presión aórtica en cada instante de tiempo
    def presion_aort():
        # Inicializar el array de la presión aórtica
        presion_aortica = np.zeros_like(tiempo_total)

        # Llenar el array 'presion_aortica' de acuerdo con cada fase en cada ciclo
        for i in range(len(tiempo_total)):
            # Ajuste del tiempo relativo al ciclo actual
            t_relativo = tiempo_total[i] % T
            if 0 <= t_relativo < T * 3 / 8:
                presion_aortica[i] = p1(t_relativo)
            elif T * 3 / 8 <= t_relativo < T * 5 / 8:
                presion_aortica[i] = p2(t_relativo)
            else:
                presion_aortica[i] = p3(t_relativo)

        # Graficar la presión aórtica
        plt.figure(figsize=(12, 6))
        plt.plot(tiempo_total, presion_aortica, color="blue", linewidth=2, label="Presión Aórtica (Simulada)")
        plt.xlabel("Tiempo (s)", fontsize=12)
        plt.ylabel("Presión (mmHg)", fontsize=12)
        plt.title("Simulación de la Presión Aórtica en Varios Ciclos", fontsize=14)
        plt.legend(loc="upper right", fontsize=10)
        plt.grid(True, linestyle="--", alpha=0.7)
        plt.ylim(0, 200)  # Ajuste de límite del eje Y para reflejar la presión máxima y mínima
        plt.show()

    # Llamada a la función para ejecutar la simulación
    presion_aort()



    # Definición de las funciones para cada fase
    def v1(x):
        return vol_medio + (vol_s * np.sin((3 / 4) * np.pi * (lpm / (60 * (2/8))) * x))

    def v2(x):
        return v1(T * (2/8))

    def v3(x):
        return vol_s + (vol_medio + vol_s * np.sin(3 / 4 * np.pi * (lpm / (60 * 2/8)) * (T * (2/8))) - vol_s) * np.exp(-30 * (x - T * (2.5/8)))

    def v4(x):
        return vol_medio - (v3(T * (5/8)) + 80) * np.exp(-30 * (x - T * (4.5/8)))

    # Función para calcular el volumen ventricular en cada instante de tiempo
    def volumen_vent():
        # Inicializar el array del volumen ventricular
        volumen_ventricular = np.zeros_like(tiempo)
        # Llenar el array 'volumen_ventricular' de acuerdo con cada fase en cada ciclo
        for i in range(len(tiempo)):
            # Calcular el tiempo en el ciclo actual (modulo T)
            tiempo_ciclo = tiempo[i] % T
            if 0 <= tiempo_ciclo < T * (2/8):
                volumen_ventricular[i] = v1(tiempo_ciclo)
            elif T * (2/8) <= tiempo_ciclo < T * (2.5/8):
                volumen_ventricular[i] = v2(tiempo_ciclo)
            elif T * (2.5/8) <= tiempo_ciclo < T * (5/8):
                volumen_ventricular[i] = v3(tiempo_ciclo)
            elif T * (5/8) <= tiempo_ciclo < T:
                volumen_ventricular[i] = v4(tiempo_ciclo)

        # Graficar el volumen ventricular
        plt.figure(figsize=(10, 6))
        plt.plot(tiempo, volumen_ventricular, color="purple", linewidth=2, label="Volumen Ventricular (Simulado)")
        plt.xlabel("Tiempo (s)", fontsize=12)
        plt.ylabel("Volumen (mL)", fontsize=12)
        plt.title("Simulación del Volumen Ventricular - 5 Ciclos", fontsize=14)
        plt.legend(loc="upper right", fontsize=10)
        plt.grid(True, linestyle="--", alpha=0.7)
        plt.ylim(0, 180)  # Ajuste de límite del eje Y para reflejar el volumen máximo
        plt.show()

    # Llamada a la función para ejecutar la simulación
    volumen_vent()
    respuesta=input("¿Desea continuar?")
    if respuesta=="no":
        i=i+1

